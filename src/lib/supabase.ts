import { createClient } from '@supabase/supabase-js'
import { Game, GamePlayer, PlayerData } from '@/types'

// Supabase configuration - these are safe to expose client-side
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// Initialize Supabase client with anon key for client-side operations
export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

/**
 * Service class for interacting with Supabase backend
 * 
 * Handles game validation and player management for the multiplayer game.
 * Uses Row Level Security (RLS) policies for data access control.
 */
export class SupabaseService {
  /**
   * Checks if a game exists in the database
   * 
   * Used to validate game codes before allowing players to join.
   * Game codes are 6-character alphanumeric strings generated by the iOS app.
   * 
   * @param gameId - 6-character game code to validate
   * @returns Promise resolving to Game object if exists, null otherwise
   */
  static async checkGameExists(gameId: string): Promise<Game | null> {
    const { data, error } = await supabase
      .from('games')
      .select('*')
      .eq('id', gameId)
      .single()

    if (error || !data) {
      return null
    }

    return data as Game
  }

  /**
   * Adds a player to an existing game
   * 
   * Creates records in both game_players and player_data tables.
   * The iOS app uses this data to synchronize players and manage game state.
   * 
   * @param gameId - 6-character game code
   * @param spotifyUser - Spotify user profile data
   * @param accessToken - Spotify access token for API calls
   * @param refreshToken - Spotify refresh token (optional)
   * @returns Promise resolving to success status and optional error message
   */
  static async joinGame(gameId: string, spotifyUser: any, accessToken: string, refreshToken?: string): Promise<{ success: boolean; error?: string }> {
    try {
      // First, insert the game player record with basic profile information
      const { data: playerData, error: playerError } = await supabase
        .from('game_players')
        .insert({
          game_id: gameId,
          spotify_user_id: spotifyUser.id,
          display_name: spotifyUser.display_name,
          email: spotifyUser.email,
          image_url: spotifyUser.images?.[0]?.url || null,
        })
        .select()
        .single()

      if (playerError) {
        return { success: false, error: playerError.message }
      }

      // Encrypt tokens using the same algorithm as iOS app
      const encryptedAccess = await this.encryptToken(accessToken, gameId)
      const encryptedRefresh = refreshToken ? await this.encryptToken(refreshToken, gameId) : null

      // Insert the player data with encrypted Spotify credentials
      const { error: dataError } = await supabase
        .from('player_data')
        .insert({
          game_player_id: playerData.id,
          encrypted_access_token: encryptedAccess,
          encrypted_refresh_token: encryptedRefresh,
          token_expiration: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
          tracks_count: 0,
          artists_count: 0,
        })

      if (dataError) {
        return { success: false, error: dataError.message }
      }

      return { success: true }
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
    }
  }

  /**
   * Encrypts a token using AES-GCM with game-specific key
   * This matches the encryption algorithm used in the iOS app
   * 
   * @param token - Token to encrypt
   * @param gameId - Game ID used as encryption key
   * @returns Promise resolving to base64-encoded encrypted token
   */
  private static async encryptToken(token: string, gameId: string): Promise<string> {
    // Import crypto for AES encryption
    const crypto = await import('crypto')
    
    // Generate encryption key from game ID using SHA256
    const key = crypto.createHash('sha256').update(gameId).digest()
    
    // Generate random IV (16 bytes for AES-256-CBC)
    const iv = crypto.randomBytes(16)
    
    // Create cipher using AES-256-CBC
    const cipher = crypto.createCipher('aes-256-cbc', key)
    
    // Encrypt the token
    let encrypted = cipher.update(token, 'utf8', 'base64')
    encrypted += cipher.final('base64')
    
    // Combine IV + encrypted data
    const combined = Buffer.concat([iv, Buffer.from(encrypted, 'base64')])
    
    return combined.toString('base64')
  }
}