import { createClient } from '@supabase/supabase-js'
import { Game, GamePlayer, PlayerData, Question, PlayerAnswer, PlayerAnswerWithQuestion } from '@/types'
import { MINIMUM_QUESTIONS } from '@/lib/constants'
import { fetchSavedTracks, fetchTopTracks } from './spotify'
import { SpotifyTrack, isTrackFromPastYear } from './spotify-search'

// Supabase configuration - these are safe to expose client-side
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// Initialize Supabase client with anon key for client-side operations
export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

/**
 * Service class for interacting with Supabase backend
 * 
 * Handles game validation and player management for the multiplayer game.
 * Uses Row Level Security (RLS) policies for data access control.
 */
export class SupabaseService {
  /**
   * Checks if a game exists in the database
   * 
   * Used to validate game codes before allowing players to join.
   * Game codes are 4-character numeric strings generated by the iOS app.
   * 
   * @param gameId - 4-character game code to validate
   * @returns Promise resolving to Game object if exists, null otherwise
   */
  static async checkGameExists(gameId: string): Promise<Game | null> {
    const { data, error } = await supabase
      .from('games')
      .select('*')
      .eq('id', gameId)
      .single()

    if (error || !data) {
      return null
    }

    return data as Game
  }

  /**
   * Adds a player to an existing game
   * 
   * Creates records in both game_players and player_data tables.
   * The iOS app uses this data to synchronize players and manage game state.
   * 
   * @param gameId - 4-character game code
   * @param spotifyUser - Spotify user profile data
   * @param accessToken - Spotify access token for API calls
   * @param refreshToken - Spotify refresh token (optional)
   * @returns Promise resolving to success status and optional error message
   */
  static async joinGame(gameId: string, spotifyUser: any, accessToken: string, refreshToken?: string): Promise<{ success: boolean; error?: string }> {
    try {
      // First, insert the game player record with basic profile information
      const { data: playerData, error: playerError } = await supabase
        .from('game_players')
        .insert({
          game_id: gameId,
          spotify_user_id: spotifyUser.id,
          display_name: spotifyUser.display_name,
          email: spotifyUser.email,
          image_url: spotifyUser.images?.[0]?.url || null,
        })
        .select()
        .single()

      if (playerError) {
        return { success: false, error: playerError.message }
      }

      // Encrypt tokens using the same algorithm as iOS app
      const encryptedAccess = await this.encryptToken(accessToken, gameId)
      const encryptedRefresh = refreshToken ? await this.encryptToken(refreshToken, gameId) : null

      // Insert the player data with encrypted Spotify credentials
      const { error: dataError } = await supabase
        .from('player_data')
        .insert({
          game_player_id: playerData.id,
          encrypted_access_token: encryptedAccess,
          encrypted_refresh_token: encryptedRefresh,
          token_expiration: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
          tracks_count: 0,
          artists_count: 0,
        })

      if (dataError) {
        return { success: false, error: dataError.message }
      }

      return { success: true }
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
    }
  }

  /**
   * Encrypts a token using AES-GCM with game-specific key
   * This matches the encryption algorithm used in the iOS app
   * 
   * @param token - Token to encrypt
   * @param gameId - Game ID used as encryption key
   * @returns Promise resolving to base64-encoded encrypted token
   */
  private static async encryptToken(token: string, gameId: string): Promise<string> {
    // Generate encryption key from game ID using SHA-256
    const encoder = new TextEncoder()
    const gameIdData = encoder.encode(gameId)
    const keyData = await crypto.subtle.digest('SHA-256', gameIdData)
    
    // Import the key for AES-GCM
    const key = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt']
    )
    
    // Generate random nonce (12 bytes for GCM)
    const nonce = crypto.getRandomValues(new Uint8Array(12))
    
    // Encrypt using AES-GCM
    const tokenData = encoder.encode(token)
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: nonce },
      key,
      tokenData
    )
    
    // The encrypted result from Web Crypto contains ciphertext + tag
    // Combine nonce + encrypted (which includes tag)
    const combined = new Uint8Array(nonce.length + encrypted.byteLength)
    combined.set(nonce, 0)
    combined.set(new Uint8Array(encrypted), nonce.length)
    
    // Convert to base64
    return Buffer.from(combined).toString('base64')
  }

  /**
   * Decrypts a token using AES-GCM with game-specific key
   * Reverses the encryption process used in encryptToken
   * 
   * @param gameId - Game ID used as decryption key
   * @param encryptedToken - Base64-encoded encrypted token
   * @returns Promise resolving to decrypted token string, or null if decryption fails
   */
  private static async decryptToken(gameId: string, encryptedToken: string): Promise<string | null> {
    try {
      // Decode base64 encrypted token
      const combined = Buffer.from(encryptedToken, 'base64')
      
      // Extract nonce (first 12 bytes) and encrypted data (remaining bytes)
      const nonce = combined.slice(0, 12)
      const encrypted = combined.slice(12)
      
      // Generate decryption key from game ID using SHA-256
      const encoder = new TextEncoder()
      const decoder = new TextDecoder()
      const gameIdData = encoder.encode(gameId)
      const keyData = await crypto.subtle.digest('SHA-256', gameIdData)
      
      // Import the key for AES-GCM decryption
      const key = await crypto.subtle.importKey(
        'raw',
        keyData,
        { name: 'AES-GCM', length: 256 },
        false,
        ['decrypt']
      )
      
      // Decrypt using AES-GCM
      const decrypted = await crypto.subtle.decrypt(
        { name: 'AES-GCM', iv: nonce },
        key,
        encrypted
      )
      
      // Convert decrypted data to string
      return decoder.decode(decrypted)
    } catch (error) {
      console.error('Error decrypting token:', error)
      return null
    }
  }

  /**
   * Gets the refresh token for a game player
   * 
   * Retrieves and decrypts the refresh token from the player_data table.
   * Used for refreshing expired access tokens.
   * 
   * @param gamePlayerId - The game_player_id
   * @param gameId - The game ID used for decryption
   * @returns Promise resolving to refresh token if found, null otherwise
   */
  static async getRefreshToken(gamePlayerId: string, gameId: string): Promise<string | null> {
    try {
      const { data, error } = await supabase
        .from('player_data')
        .select('encrypted_refresh_token')
        .eq('game_player_id', gamePlayerId)
        .single()

      if (error || !data || !data.encrypted_refresh_token) {
        return null
      }

      // Decrypt the refresh token
      const refreshToken = await this.decryptToken(gameId, data.encrypted_refresh_token)
      return refreshToken
    } catch (error) {
      console.error('Error fetching refresh token:', error)
      return null
    }
  }

  /**
   * Fetches all active questions ordered by display order
   * 
   * Used to display questions for player selection.
   * 
   * @returns Promise resolving to array of active questions, or empty array on error
   */
  static async getActiveQuestions(): Promise<Question[]> {
    try {
      const { data, error } = await supabase
        .from('questions')
        .select('*')
        .eq('is_active', true)
        .order('display_order', { ascending: true })

      if (error) {
        console.error('Error fetching active questions:', error)
        return []
      }

      return (data || []) as Question[]
    } catch (error) {
      console.error('Error fetching active questions:', error)
      return []
    }
  }

  /**
   * Gets the game_player_id for a player in a specific game
   * 
   * Used to check if a player already exists in a game before checking answers.
   * 
   * @param gameId - 4-character game code
   * @param spotifyUserId - Spotify user ID
   * @returns Promise resolving to game_player_id if found, null otherwise
   */
  static async getGamePlayerId(gameId: string, spotifyUserId: string): Promise<string | null> {
    try {
      const { data, error } = await supabase
        .from('game_players')
        .select('id')
        .eq('game_id', gameId)
        .eq('spotify_user_id', spotifyUserId)
        .single()

      if (error || !data) {
        return null
      }

      return data.id
    } catch (error) {
      console.error('Error fetching game player ID:', error)
      return null
    }
  }

  /**
   * Fetches all answers for a player with question details
   * 
   * Used to display existing answers when player returns to update them.
   * 
   * @param gamePlayerId - The game_player_id to fetch answers for
   * @returns Promise resolving to array of answers with question details, or empty array on error
   */
  static async getPlayerAnswers(gamePlayerId: string): Promise<PlayerAnswerWithQuestion[]> {
    try {
      const { data, error } = await supabase
        .from('player_question_answers')
        .select('*, questions(*)')
        .eq('game_player_id', gamePlayerId)

      if (error) {
        console.error('Error fetching player answers:', error)
        return []
      }

      return (data || []) as PlayerAnswerWithQuestion[]
    } catch (error) {
      console.error('Error fetching player answers:', error)
      return []
    }
  }

  /**
   * Saves or updates a player's answer for a question
   * 
   * Uses UPSERT to handle both new answers and updates to existing answers.
   * Extracts track metadata from Spotify track object.
   * 
   * @param gamePlayerId - The game_player_id
   * @param questionId - The question_id
   * @param track - Spotify track object from API
   * @returns Promise resolving to success status and optional error message
   */
  static async saveAnswer(
    gamePlayerId: string,
    questionId: string,
    track: {
      id: string
      name: string
      artists: Array<{ name: string }>
      album: {
        name: string
        images: Array<{ url: string }>
        release_date: string
      }
      external_urls: { spotify: string }
      preview_url: string | null
    }
  ): Promise<{ success: boolean; error?: string }> {
    try {
      // Extract release year from release_date (format: YYYY-MM-DD or YYYY)
      const releaseYear = track.album.release_date
        ? track.album.release_date.substring(0, 4)
        : null

      const { error } = await supabase
        .from('player_question_answers')
        .upsert(
          {
            game_player_id: gamePlayerId,
            question_id: questionId,
            track_id: track.id,
            track_name: track.name,
            artist_name: track.artists[0]?.name || '',
            album_name: track.album.name,
            album_image_url: track.album.images[0]?.url || null,
            release_year: releaseYear,
            external_url: track.external_urls.spotify,
            preview_url: track.preview_url || null,
          },
          {
            onConflict: 'game_player_id,question_id',
          }
        )

      if (error) {
        return { success: false, error: error.message }
      }

      return { success: true }
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * Checks if a player has the minimum required number of answers
   * 
   * Uses the Supabase RPC function to check readiness.
   * 
   * @param gamePlayerId - The game_player_id to check
   * @returns Promise resolving to true if player has minimum answers, false otherwise
   */
  static async checkPlayerReadiness(gamePlayerId: string): Promise<boolean> {
    try {
      const { data, error } = await supabase.rpc('player_has_minimum_answers', {
        p_game_player_id: gamePlayerId,
        p_minimum: MINIMUM_QUESTIONS,
      })

      if (error) {
        console.error('Error checking player readiness:', error)
        return false
      }

      return data === true
    } catch (error) {
      console.error('Error checking player readiness:', error)
      return false
    }
  }

  /**
   * Deletes a player's answer for a question
   * 
   * @param gamePlayerId - The game_player_id
   * @param questionId - The question_id to delete answer for
   * @returns Promise resolving to success status and optional error message
   */
  static async deleteAnswer(
    gamePlayerId: string,
    questionId: string
  ): Promise<{ success: boolean; error?: string }> {
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:406',message:'deleteAnswer called',data:{gamePlayerId,questionId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    try {
      const { data, error } = await supabase
        .from('player_question_answers')
        .delete()
        .eq('game_player_id', gamePlayerId)
        .eq('question_id', questionId)
        .select()

      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:416',message:'deleteAnswer query result',data:{gamePlayerId,questionId,hasError:!!error,errorMessage:error?.message,dataLength:data?.length,deletedRows:data},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion

      if (error) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:418',message:'deleteAnswer error from Supabase',data:{gamePlayerId,questionId,errorMessage:error.message},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        return { success: false, error: error.message }
      }

      // Check if any rows were actually deleted
      if (!data || data.length === 0) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:423',message:'deleteAnswer: no rows deleted',data:{gamePlayerId,questionId,dataLength:data?.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
        // #endregion
        return { 
          success: false, 
          error: 'No answer found to delete. It may have already been deleted or you may not have permission.' 
        }
      }

      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:430',message:'deleteAnswer success',data:{gamePlayerId,questionId,deletedCount:data.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      return { success: true }
    } catch (error) {
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:432',message:'deleteAnswer exception caught',data:{gamePlayerId,questionId,errorMessage:error instanceof Error ? error.message : 'Unknown error'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * Extracts player tracks from Spotify and stores them in the database
   * 
   * Fetches saved tracks (50) and top tracks (100), combines and deduplicates,
   * filters to past year, and stores in extracted_tracks table.
   * Always refreshes by deleting existing tracks first.
   * 
   * @param gamePlayerId - The game_player_id
   * @param accessToken - Valid Spotify access token
   * @returns Promise resolving to success status, count of tracks extracted, and optional error
   */
  static async extractPlayerTracks(
    gamePlayerId: string,
    accessToken: string
  ): Promise<{ success: boolean; count: number; error?: string }> {
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:441',message:'extractPlayerTracks entry',data:{gamePlayerId,hasAccessToken:!!accessToken},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
    // #endregion
    try {
      // Fetch saved tracks (up to 50)
      const savedTracks = await fetchSavedTracks(accessToken, 50)
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:447',message:'savedTracks fetched',data:{savedTracksCount:savedTracks.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion

      // Fetch top tracks (up to 100)
      const topTracks = await fetchTopTracks(accessToken, 100)
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:450',message:'topTracks fetched',data:{topTracksCount:topTracks.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion

      // Combine and deduplicate by track ID (keep first occurrence)
      const allTracks = [
        ...savedTracks.map((t) => ({ track: t, source: 'saved' as const })),
        ...topTracks.map((t) => ({ track: t, source: 'top' as const })),
      ]

      const uniqueTracks = Array.from(
        new Map(allTracks.map((item) => [item.track.id, item])).values()
      )

      // Filter to past year
      const pastYearTracks = uniqueTracks.filter((item) =>
        isTrackFromPastYear(item.track)
      )
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:463',message:'tracks filtered to past year',data:{uniqueTracksCount:uniqueTracks.length,pastYearTracksCount:pastYearTracks.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
      // #endregion

      // Delete existing tracks for this player (always refresh)
      const { error: deleteError } = await supabase
        .from('extracted_tracks')
        .delete()
        .eq('game_player_id', gamePlayerId)

      if (deleteError) {
        return {
          success: false,
          count: 0,
          error: `Failed to delete existing tracks: ${deleteError.message}`,
        }
      }

      // Store in database
      await this.storeExtractedTracks(gamePlayerId, pastYearTracks)
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:482',message:'tracks stored successfully',data:{count:pastYearTracks.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion

      return { success: true, count: pastYearTracks.length }
    } catch (error) {
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:486',message:'extractPlayerTracks error',data:{error:error instanceof Error ? error.message : 'Unknown error'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
      // #endregion
      return {
        success: false,
        count: 0,
        error: error instanceof Error ? error.message : 'Unknown error',
      }
    }
  }

  /**
   * Retrieves extracted tracks for a player from the database
   * 
   * @param gamePlayerId - The game_player_id
   * @returns Promise resolving to array of Spotify tracks, or empty array if none found
   */
  static async getExtractedTracks(gamePlayerId: string): Promise<SpotifyTrack[]> {
    // #region agent log
    fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:500',message:'getExtractedTracks entry',data:{gamePlayerId},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
    // #endregion
    try {
      const { data, error } = await supabase
        .from('extracted_tracks')
        .select('*')
        .eq('game_player_id', gamePlayerId)

      if (error) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:507',message:'getExtractedTracks query error',data:{error:error.message},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        console.error('Error fetching extracted tracks:', error)
        return []
      }

      if (!data || data.length === 0) {
        // #region agent log
        fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:512',message:'getExtractedTracks empty result',data:{dataLength:data?.length || 0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
        // #endregion
        return []
      }

      // Convert database records to SpotifyTrack format
      const tracks = data.map((record) => ({
        id: record.track_id,
        name: record.track_name,
        artists: [{ name: record.artist_name }],
        album: {
          name: record.album_name || '',
          images: record.album_image_url ? [{ url: record.album_image_url }] : [],
          release_date: record.release_year ? `${record.release_year}-01-01` : '',
        },
        external_urls: { spotify: record.external_url },
        preview_url: record.preview_url || null,
      }))
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:528',message:'getExtractedTracks success',data:{tracksCount:tracks.length},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      return tracks
    } catch (error) {
      // #region agent log
      fetch('http://127.0.0.1:7243/ingest/c8f47d84-03f9-42b8-b409-8b436f7ea2e8',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'supabase.ts:530',message:'getExtractedTracks exception',data:{error:error instanceof Error ? error.message : 'Unknown error'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C'})}).catch(()=>{});
      // #endregion
      console.error('Error fetching extracted tracks:', error)
      return []
    }
  }

  /**
   * Stores extracted tracks in the database
   * 
   * Bulk inserts tracks into extracted_tracks table using UPSERT to handle duplicates.
   * 
   * @param gamePlayerId - The game_player_id
   * @param tracks - Array of tracks with source information
   * @returns Promise resolving to void
   */
  static async storeExtractedTracks(
    gamePlayerId: string,
    tracks: Array<{ track: SpotifyTrack; source: 'saved' | 'top' }>
  ): Promise<void> {
    if (tracks.length === 0) {
      return
    }

    try {
      // Map tracks to database schema
      const records = tracks.map(({ track, source }) => {
        const releaseYear = track.album.release_date
          ? track.album.release_date.substring(0, 4)
          : null

        return {
          game_player_id: gamePlayerId,
          track_id: track.id,
          track_name: track.name,
          artist_name: track.artists[0]?.name || '',
          album_name: track.album.name || null,
          album_image_url: track.album.images[0]?.url || null,
          release_year: releaseYear,
          external_url: track.external_urls.spotify,
          preview_url: track.preview_url || null,
          source,
        }
      })

      // Bulk insert using UPSERT to handle duplicates
      const { error } = await supabase.from('extracted_tracks').upsert(records, {
        onConflict: 'game_player_id,track_id',
      })

      if (error) {
        throw new Error(`Failed to store extracted tracks: ${error.message}`)
      }
    } catch (error) {
      console.error('Error storing extracted tracks:', error)
      throw error
    }
  }
}