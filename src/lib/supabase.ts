import { createClient } from '@supabase/supabase-js'
import { Game, GamePlayer, PlayerData } from '@/types'

// Supabase configuration - these are safe to expose client-side
const SUPABASE_URL = process.env.NEXT_PUBLIC_SUPABASE_URL!
const SUPABASE_ANON_KEY = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

// Initialize Supabase client with anon key for client-side operations
export const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

/**
 * Service class for interacting with Supabase backend
 * 
 * Handles game validation and player management for the multiplayer game.
 * Uses Row Level Security (RLS) policies for data access control.
 */
export class SupabaseService {
  /**
   * Checks if a game exists in the database
   * 
   * Used to validate game codes before allowing players to join.
   * Game codes are 6-character alphanumeric strings generated by the iOS app.
   * 
   * @param gameId - 6-character game code to validate
   * @returns Promise resolving to Game object if exists, null otherwise
   */
  static async checkGameExists(gameId: string): Promise<Game | null> {
    const { data, error } = await supabase
      .from('games')
      .select('*')
      .eq('id', gameId)
      .single()

    if (error || !data) {
      return null
    }

    return data as Game
  }

  /**
   * Adds a player to an existing game
   * 
   * Creates records in both game_players and player_data tables.
   * The iOS app uses this data to synchronize players and manage game state.
   * 
   * @param gameId - 6-character game code
   * @param spotifyUser - Spotify user profile data
   * @param accessToken - Spotify access token for API calls
   * @param refreshToken - Spotify refresh token (optional)
   * @returns Promise resolving to success status and optional error message
   */
  static async joinGame(gameId: string, spotifyUser: any, accessToken: string, refreshToken?: string): Promise<{ success: boolean; error?: string }> {
    try {
      // First, insert the game player record with basic profile information
      const { data: playerData, error: playerError } = await supabase
        .from('game_players')
        .insert({
          game_id: gameId,
          spotify_user_id: spotifyUser.id,
          display_name: spotifyUser.display_name,
          email: spotifyUser.email,
          image_url: spotifyUser.images?.[0]?.url || null,
        })
        .select()
        .single()

      if (playerError) {
        return { success: false, error: playerError.message }
      }

      // Encrypt tokens using the same algorithm as iOS app
      const encryptedAccess = await this.encryptToken(accessToken, gameId)
      const encryptedRefresh = refreshToken ? await this.encryptToken(refreshToken, gameId) : null

      // Insert the player data with encrypted Spotify credentials
      const { error: dataError } = await supabase
        .from('player_data')
        .insert({
          game_player_id: playerData.id,
          encrypted_access_token: encryptedAccess,
          encrypted_refresh_token: encryptedRefresh,
          token_expiration: new Date(Date.now() + 3600000).toISOString(), // 1 hour from now
          tracks_count: 0,
          artists_count: 0,
        })

      if (dataError) {
        return { success: false, error: dataError.message }
      }

      return { success: true }
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : 'Unknown error' }
    }
  }

  /**
   * Encrypts a token using AES-GCM with game-specific key
   * This matches the encryption algorithm used in the iOS app
   * 
   * @param token - Token to encrypt
   * @param gameId - Game ID used as encryption key
   * @returns Promise resolving to base64-encoded encrypted token
   */
  private static async encryptToken(token: string, gameId: string): Promise<string> {
    // Generate encryption key from game ID using SHA-256
    const encoder = new TextEncoder()
    const gameIdData = encoder.encode(gameId)
    const keyData = await crypto.subtle.digest('SHA-256', gameIdData)
    
    // Import the key for AES-GCM
    const key = await crypto.subtle.importKey(
      'raw',
      keyData,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt']
    )
    
    // Generate random nonce (12 bytes for GCM)
    const nonce = crypto.getRandomValues(new Uint8Array(12))
    
    // Encrypt using AES-GCM
    const tokenData = encoder.encode(token)
    const encrypted = await crypto.subtle.encrypt(
      { name: 'AES-GCM', iv: nonce },
      key,
      tokenData
    )
    
    // The encrypted result from Web Crypto contains ciphertext + tag
    // Combine nonce + encrypted (which includes tag)
    const combined = new Uint8Array(nonce.length + encrypted.byteLength)
    combined.set(nonce, 0)
    combined.set(new Uint8Array(encrypted), nonce.length)
    
    // Convert to base64
    return Buffer.from(combined).toString('base64')
  }
}